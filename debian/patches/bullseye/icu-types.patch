--- a/v8/src/objects/intl-objects.h
+++ b/v8/src/objects/intl-objects.h
@@ -21,7 +21,7 @@
 #include "unicode/locid.h"
 #include "unicode/uversion.h"
 
-#define V8_MINIMUM_ICU_VERSION 69
+#define V8_MINIMUM_ICU_VERSION 67
 
 namespace U_ICU_NAMESPACE {
 class BreakIterator;
--- a/v8/src/objects/intl-objects.cc
+++ b/v8/src/objects/intl-objects.cc
@@ -2551,12 +2551,10 @@ bool ICUTimezoneCache::GetOffsets(double
   if (is_utc) {
     GetTimeZone()->getOffset(time_ms, false, *raw_offset, *dst_offset, status);
   } else {
-    // Note that casting TimeZone to BasicTimeZone is safe because we know that
-    // icu::TimeZone used here is a BasicTimeZone.
     static_cast<const icu::BasicTimeZone*>(GetTimeZone())
-        ->getOffsetFromLocal(time_ms, UCAL_TZ_LOCAL_FORMER,
-                             UCAL_TZ_LOCAL_FORMER, *raw_offset, *dst_offset,
-                             status);
+        ->getOffsetFromLocal(time_ms, icu::BasicTimeZone::kFormer,
+                             icu::BasicTimeZone::kFormer, *raw_offset,
+                             *dst_offset, status);
   }
 
   return U_SUCCESS(status);
--- a/third_party/blink/renderer/platform/wtf/date_math.cc
+++ b/third_party/blink/renderer/platform/wtf/date_math.cc
@@ -672,8 +672,9 @@ absl::optional<base::Time> ParseDateFrom
     // Handle the conversion of localtime to UTC the same way as the
     // latest ECMA 262 spec for Javascript (v8 does that, too).
     static_cast<const icu::BasicTimeZone*>(timezone.get())
-        ->getOffsetFromLocal(ms, UCAL_TZ_LOCAL_FORMER, UCAL_TZ_LOCAL_FORMER,
-                             raw_offset, dst_offset, status);
+        ->getOffsetFromLocal(ms, icu::BasicTimeZone::kFormer,
+                             icu::BasicTimeZone::kFormer, raw_offset,
+                             dst_offset, status);
     DCHECK(U_SUCCESS(status));
     offset = static_cast<int>((raw_offset + dst_offset) / kMsPerMinute);
   }
