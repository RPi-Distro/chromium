author: Andres Salomon <dilinger@debian.org>
description: work around https://github.com/llvm/llvm-project/issues/48582

../../media/base/cdm_promise_adapter.cc:99:66: error: reference to local binding 'promise_id' declared in enclosing function 'media::CdmPromiseAdapter::Clear'
        "media", "CdmPromise", TRACE_ID_WITH_SCOPE("CdmPromise", promise_id),
                                                                 ^
../../media/base/cdm_promise_adapter.cc:97:15: note: 'promise_id' declared here
  for (auto& [promise_id, promise] : promises_) {
              ^

This is some kind of clang14 scope bug, whereby variable are defined
in a structured binding, and then used inside of a (valid, but) different
scope. Eg,
  auto& [foo, bar, baz] = sizing_tree->CreateSizingData();
  do { auto& x = bar; } while (0);
  auto x = [&](GridTrackSizingDirection lambdavar) {
    for (auto& i : foo) { ... } 
  }
The compiler gets confused about scope and spits out an error. The
workaround is to define the variable not in a structured binding.

--- a/media/base/cdm_promise_adapter.cc
+++ b/media/base/cdm_promise_adapter.cc
@@ -94,7 +94,9 @@ void CdmPromiseAdapter::RejectPromise(ui
 void CdmPromiseAdapter::Clear(ClearReason reason) {
   // Reject all outstanding promises.
   DCHECK(thread_checker_.CalledOnValidThread());
-  for (auto& [promise_id, promise] : promises_) {
+  for (auto& [p_id, p] : promises_) {
+    auto& promise_id = p_id;
+    auto& promise = p;
     TRACE_EVENT_NESTABLE_ASYNC_END1(
         "media", "CdmPromise", TRACE_ID_WITH_SCOPE("CdmPromise", promise_id),
         "status", "cleared");
--- a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
@@ -1798,8 +1798,10 @@ void NGGridLayoutAlgorithm::CompleteTrac
     bool* opt_needs_additional_pass) const {
   DCHECK(sizing_subtree);
 
-  auto& [grid_items, layout_data, subtree_size] =
+  auto& [g_i, l_d, subtree_size] =
       sizing_subtree.SubtreeRootData();
+  auto& grid_items = g_i;
+  auto& layout_data = l_d;
 
   const bool is_for_columns = track_direction == kForColumns;
   const bool has_non_definite_track =
--- a/content/browser/service_worker/service_worker_context_wrapper.cc
+++ b/content/browser/service_worker/service_worker_context_wrapper.cc
@@ -1393,7 +1393,8 @@ void ServiceWorkerContextWrapper::MaybeP
     return;
   }
 
-  auto [document_url, key, callback] = std::move(*request);
+  auto [d_u, key, callback] = std::move(*request);
+  auto document_url = std::move(d_u);
 
   DCHECK(document_url.is_valid());
   TRACE_EVENT1("ServiceWorker",
--- a/chrome/browser/ui/autofill/chrome_autofill_client.cc
+++ b/chrome/browser/ui/autofill/chrome_autofill_client.cc
@@ -1100,7 +1100,8 @@ void ChromeAutofillClient::PropagateAuto
           &renderer_form);
     }
 
-    for (const auto& [frame_token, frame_forms] : renderer_forms_by_frame) {
+    for (const auto& [f_t, frame_forms] : renderer_forms_by_frame) {
+      auto& frame_token = f_t;
       // Attempt to find the RFH with this `frame_token`.
       content::RenderFrameHost* rfh = nullptr;
       GetWebContents().ForEachRenderFrameHost(
--- a/components/download/public/common/download_save_item_data.h
+++ b/components/download/public/common/download_save_item_data.h
@@ -27,7 +27,7 @@ class COMPONENTS_DOWNLOAD_EXPORT Downloa
     // The referrer url for this file. (In case of a package download this is
     // the main page for the other resources.)
     GURL referrer_url;
-    ItemInfo(auto fp, u, ru) : file_path(fp), url(u), referrer_url(ru) { }
+    ItemInfo(auto fp, auto u, auto ru) : file_path(fp), url(u), referrer_url(ru) { }
   };
 
   explicit DownloadSaveItemData(std::vector<ItemInfo>&& item_infos);
--- a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
@@ -3433,7 +3433,8 @@ void NGGridLayoutAlgorithm::PlaceGridIte
   DCHECK(out_row_break_between);
 
   const auto& container_space = ConstraintSpace();
-  const auto& [grid_items, layout_data, tree_size] = sizing_tree.TreeRootData();
+  const auto& [grid_items, l_d, tree_size] = sizing_tree.TreeRootData();
+  const auto& layout_data = l_d;
 
   const auto* cached_layout_subtree = container_space.GridLayoutSubtree();
   const auto container_writing_direction =
@@ -3597,7 +3598,9 @@ void NGGridLayoutAlgorithm::PlaceGridIte
 
   // TODO(ikilpatrick): Update |SetHasSeenAllChildren| and early exit if true.
   const auto& constraint_space = ConstraintSpace();
-  const auto& [grid_items, layout_data, tree_size] = sizing_tree.TreeRootData();
+  const auto& [g_i, l_d, tree_size] = sizing_tree.TreeRootData();
+  const auto& grid_items = g_i;
+  const auto& layout_data = l_d;
 
   const auto* cached_layout_subtree = constraint_space.GridLayoutSubtree();
   const auto container_writing_direction =
